- 코드가 하는 일이 무엇인지
- 어떻게 그 일을 수행하는지
- (입력이나 상태 등) 어떤 것을 필요로 하는지
- 코드 실행의 결과는 무엇인지 

명확하게 보이는 코드입니다. 

그전에 왜 ***가독성***일까요?
다음 링크를 확인합시다. 
	https://medium.com/naver-cloud-platform/%EB%84%A4%EC%9D%B4%EB%B2%84%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9C-%EA%B0%9C%EB%B0%9C%EC%9E%90-%EC%8A%A4%ED%86%A0%EB%A6%AC-%EC%A2%8B%EC%9D%80-%EC%BD%94%EB%93%9C%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C-%ED%81%B4%EB%A6%B0%EC%BD%94%EB%93%9C-%EC%9D%B4%EC%95%BC%EA%B8%B0-c7811f73a46b
#### 가독성을 좋게 하는 방법

1. 일관성을 유지하자
	어떤 스타일이든 중요하지 않습니다. 우선 그 스타일을 일관성 있게 유지하는 것이 중요합니다.
2. 롬복을 사용하자 
	```java
	@NoArgsConstructor
	@AllArgsConstructor
	@Data
	@EqualsAndHashCode
	class User {
		private String firstName;
		private String lastName;
		private String email;
	}
```
3. 조건에 이름을 붙이자 
	`Predicate` 객체를 사용해서 if 조건문을 업그레이드 하는 방법입니다. `Predicate`는 가독성 뿐만 아니라 재 사용성도 증가시킬 수 있습니다. 예를 들어, 유저의 나이를 통해 adult / children을 구분 해야 하는 코드가 여러 줄에 들어간다면 이를 `Predicate` 객체에서 추출해서 사용할 수 있습니다.

	따라서 다음 코드는 
	```java
	if (user.getAge() >= 18) {
		// adult 
	}

	var adults = users.stream().filter( user -> user.getAge() >= 18 ) ;
	var children = users.stream.filter( user -> user.getAge() < 18 ) ;	
	```
	이렇게 변경 가능합니다.
	```java
	Predicate<User> adultUser = user -> user.getAge() >= 18;

	var adults = user.steram().filter(adultUser);
	var children = user.stream().filter(adultUser.negate());
```
4. Fluent API를 사용하자
	Fluent API는 메소드 체이닝에 상당 부분 기반한 객체 지향 API 설계 메소드입니다. 
	
	![[Fluent API.png]]
5. 이중 부정을 하지 말자
	```java
	if(!user.isDisabled()){
		...
	}
```
	위 코드 대신 다음을 사용합니다.
```java
	if(user.isEnabled()){
		...
	}
```
6. 잦은 중첩 클래스를 지양하자 
	```java
	topLevelObjects.forEach( topLevelObject -> {
	   topLevelObject.getSecondLevelObjects().forEach ( secondLevelObj -> {
         secondLevelObj.getThirdLevelObjects().forEach( thirdLevelObj -> {
      });
   });
  });
```
7. Null 대신 Optional을 반환하자
8. MultiCatch를 사용하자
9. 네 개 이상의 매개변수는 리팩토링 하자 
10. 잦은 주석 사용을 자제하자 
#### Reference
- Good code, Bad code 
- https://www.linkedin.com/pulse/10-practical-tips-writing-clean-readable-java-code-yusuf-nadir-saghar