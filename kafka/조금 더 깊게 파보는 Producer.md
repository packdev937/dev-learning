프로듀서를 사용해서 메세지를 보내는 코드를 작성해봅시다. 
```java
Properties prop = new Properties();
prop.put("bootstrap.servers", "kafka01:9092, kafka01:9092, kafka01:9092");
prop.put("key.serializer", "org.apache.kafka.common.serialization.StringSerializer");
prop.put("value.serializer", "org.apache.kafka.common.serialization.StringSerializer");

KafkaProducer<Integer, String> producer = new KafkaProducer<>(prop);

producer.send(new ProducerRecord<>("topicname", "key", "value"));
producer.send(new ProducerRecord<>("topicname", "value"));

producer.close();
```

### 프로듀서의 기본 흐름 
![[스크린샷 2024-03-29 오전 11.21.20.png]]
send()를 이용해서 레코드를 전송하면 먼저 Serializer를 이용해서 Byte로 변환합니다.
그리고 Partitioner를 이용해서 해당 메세지를 어느 토픽의 파티션으로 보낼 지 결정합니다. 그리고 변환 된 바이트 배열 메세지를 버퍼에 저장합니다. 

그 때 버퍼에 바로 저장하는 것이 아니고 배치로 묶어서 저장하게 됩니다. 카프카의 성능이 좋은 이유 중 하나는 여러 메세지를 묶어서 전송하기 때문입니다. 

Sender가 배치를 차례대로 가져와서 카프카 브로커로 전송을 합니다. 

Sender가는 별도의 스레드로 동작합니다. Sender는 배치를 차례대로 꺼내어 브로커로 보내는데 배치가 찾는지 여부에 상관없이 읽어서 보냅니다. Sender가 배치를 브로커에 보내는 동안 send() 메소드를 통해 들어오는 레코드는 계속 배치에 누적 되어 쌓이게 됩니다. 

따라서 Sender는 Sender 대로 배치를 꺼내 브로커로 보내고, send()는 계속해서 배치에 메세지를 누적 하게 됩니다. 즉, 둘은 비동기 적으로 처리됩니다. 

Sender는 배치가 다 차지 않아도 바로 보냅니다. 즉, 배치에 메세지가 한 개가 있건 여러 개가 있건 보낼 수 있는 환경이면 다 보냅니다. 

따라서 배치와 Sender와 관련된 설정이 처리량에 영향을 줍니다. 
먼저 배치 사이즈 설정이 존재합니다. 해당 설정은 배치의 최대 크기를 지정합니다. 그리고 해당 크기 만큼 배치의 메세지가 차면 배치를 바로 전송하게 됩니다. 그래서 배치 사이즈가 너무 작으면  한 번에 보낼 수 있는 메세지의 개수가 적어지고 전송 회수가 많아지기 때문에 처리량이 떨어지게 됩니다.

linger.ms 는 Sender가 배치를 전송하는 대기 시간을 진행합니다. 만약 해당 대기 시간이 없으면 대기 시간 없이 앞의 배치를 보낸 다음에 바로 다음 배치를 전송합니다.
대기 시간을 주게 되면 그 시간 만큼 기다렸다가 배치를 전송합니다. 
대기 시간을 주면 그 시간 만큼 기다리기 때문에 배치에 메세지가 쌓이게 되고 한 번에 더 많은 메세지를 보낼 수 있게 됩니다. 즉, 전반적인 처리량이 높아지는 효과를 볼 수 있습니다.

```java
producer.send(new ProducerRecord<>("simple", "value"));
```

만약 다음과 같이 코드를 짠다면 메소드의 레코드가 전달이 성공적으로 되었는지 안되었는지 판단하기 힘듭니다.

만약 메세지 전송 여부를 판단하고 싶으면 다음과 같이 코드를 짜 볼 수 있습니다.
```
Future<RecordMetadata> f = producer.send(new ProducerRecord<>("topic", "value"));
try {
	RecordMetedata meta = f.get() // 블로킹
} catch (ExecutionException ex){

}
```

이렇게 하면 블로킹 때문에 배치에 메세지가 쌓이지 않습니다. 대신 건 별로 확실하게 결과를 알 수 있습니다. 따라서 위 방식은 처리량이 낮아도 되는 경우에 사용합니다.

```java
producer.send(new ProducerRecord<>("simple", "value")),
	new Callback() {
		@Override
		public void onCompletion(RecrodMetadata metadata, Exception ex){
		}
	}
)
```

또 다른 방법은 센드 메소드에 콜백 메소드를 전달하는 것입니다. 콜백 메소드는 전송이 완료되면 결과를 onComplete으로 받게 됩니다. 이 때 예외를 받게 되면 전송에 실패된 것임으로 후처리를 할 수 있습니다. 위 방식은 블로킹 방식이 아니기 때문에 배치에 영향을 주지 않습니다.

### 전송 보장과 ACK 
프로듀서는 전송을 보장하기 위해서 ACK 값을 사용합니다. 
- ACK = 0
	- 서버로 부터 응답을 기다리지 않습니다. 즉, 전송을 보장하지 않습니다.
	- 처리량은 높아질 수 있으나 메세지가 유실되더라도 실패 여부를 알 수 없기 때문에 메세지 전송 여부가 중요한 경우 ACK = 0의 사용은 권장되지 않습니다.
- ACK = 1
	- 파티션의 리더에 저장이 되면 성공 응답을 받게 됩니다. 따라서 리더에 장애가 발생하면 메세지가 유실될 가능성이 있습니다. 
	- 예를 들어, 리더에는 성공적으로 메세지를 전송 받았는데 이를 팔로워로 복제 하는 과정에서 오류가 났다면 그것을 확인할 방법이 없습니다. 
- ACK = ALL
	- 엄격하게 전송을 보장해야 할 때 ALL로 지정합니다. 
	- 브로커 min.insync.replicas 설정에 따라 달라집니다. 

##### min.insync.replicas 옵션이란?
프로듀사 ACK 옵션이 ALL 일 때 저장에 성공했다고 응답할 수 있는 동기화 된 리플리카의 최소 개수 

예를 들어, 리플리카의 개수가 3이고 min.insync.replicas가 2일 때 리더에 저장하고 팔로워에 한 개를 저장하면 성곡 응답을 반환합니다. 

반면 min.insync.replicas가 1이라면 ACK가 1일 떄와 동일한 효과를 얻을 수 있습니다. 리더에게만 저장하면 되기 때문입니다.

### 에러 유형 
개발자에게 에러는 숙명입니다. 카프카도 마찬가지인데요, 프로듀서에서는 크게 두 가지 종류의 에러가 발생할 수 있습니다.
##### 전송 과정에서 실패
- 전송하는 과정에서 타임 아웃이 발생
- 리더가 문제가 생겨 새로운 리더를 선출 진행
- 브로커 설정 메세지 크기의 한도 초과
##### 전송 전에 실패
- 직렬화에 실패
- 프로듀서 자체 요청 크기 제한 초과
- 프로듀서 버퍼가 차서 기다린 시간이 최대 대기 시간을 초과 

#### 어떻게 대응해야될까?
첫 번째로 재시도 가능한 에러는 재시도 합니다. 브로커 응답의 타임 아웃이 발생했거나, 리더가 일시적으로 없는 경우는 잠시 기다렸다가 다시 메세지를 전송하면 성공 가능성이 높습니다. 

프로듀서는 기본적으로 재시도를 합니다. 또한 Exception Type에 따라서 재시도 가능 여부를 판단할 수 있습니다. 

하지만 재시도는 일정 시간이나 횟수를 제한할 필요가 있습니다.

두 번째로 실패한 메세지를 별도의 파일, 디비에 기록을 해놓는 것입니다. 해당 메세지는 추후에 다시 시도해주면 되겠죠. 
기록 위치는 다음과 같습니다. 
- send() 메서드에서 익셉션 발생 시 
- send() 메서드에 전달한 콜백에서 익셉션을 받는 경우
- send() 메서드가 리턴한 Future의 get() 메서드에서 익셉션 발생 시 

##### 재시도 시 주의할 점
메세지가 중복 전송 될 가능성이 있습니다. 프로듀서에서 보낸 메세지가 브로커에 성공적으로 저장됐는데 ACK 응답이 조금 느려 다시 재전송 될 가능성이 있습니다. 
- enable.idempotence 속성을 통해 오류를 조금 줄일 수 있다고 합니다. 